// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/task.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2ftask_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_proto_2ftask_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2ftask_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2ftask_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_proto_2ftask_2eproto;
namespace taskscheduler {
class SchedulerHeartbeat;
struct SchedulerHeartbeatDefaultTypeInternal;
extern SchedulerHeartbeatDefaultTypeInternal _SchedulerHeartbeat_default_instance_;
class SchedulerHeartbeat_DecEntry_DoNotUse;
struct SchedulerHeartbeat_DecEntry_DoNotUseDefaultTypeInternal;
extern SchedulerHeartbeat_DecEntry_DoNotUseDefaultTypeInternal _SchedulerHeartbeat_DecEntry_DoNotUse_default_instance_;
class Task;
struct TaskDefaultTypeInternal;
extern TaskDefaultTypeInternal _Task_default_instance_;
class TaskResult;
struct TaskResultDefaultTypeInternal;
extern TaskResultDefaultTypeInternal _TaskResult_default_instance_;
class Task_MetadataEntry_DoNotUse;
struct Task_MetadataEntry_DoNotUseDefaultTypeInternal;
extern Task_MetadataEntry_DoNotUseDefaultTypeInternal _Task_MetadataEntry_DoNotUse_default_instance_;
class WorkerHeartbeat;
struct WorkerHeartbeatDefaultTypeInternal;
extern WorkerHeartbeatDefaultTypeInternal _WorkerHeartbeat_default_instance_;
class WorkerHeartbeat_DecEntry_DoNotUse;
struct WorkerHeartbeat_DecEntry_DoNotUseDefaultTypeInternal;
extern WorkerHeartbeat_DecEntry_DoNotUseDefaultTypeInternal _WorkerHeartbeat_DecEntry_DoNotUse_default_instance_;
}  // namespace taskscheduler
PROTOBUF_NAMESPACE_OPEN
template<> ::taskscheduler::SchedulerHeartbeat* Arena::CreateMaybeMessage<::taskscheduler::SchedulerHeartbeat>(Arena*);
template<> ::taskscheduler::SchedulerHeartbeat_DecEntry_DoNotUse* Arena::CreateMaybeMessage<::taskscheduler::SchedulerHeartbeat_DecEntry_DoNotUse>(Arena*);
template<> ::taskscheduler::Task* Arena::CreateMaybeMessage<::taskscheduler::Task>(Arena*);
template<> ::taskscheduler::TaskResult* Arena::CreateMaybeMessage<::taskscheduler::TaskResult>(Arena*);
template<> ::taskscheduler::Task_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::taskscheduler::Task_MetadataEntry_DoNotUse>(Arena*);
template<> ::taskscheduler::WorkerHeartbeat* Arena::CreateMaybeMessage<::taskscheduler::WorkerHeartbeat>(Arena*);
template<> ::taskscheduler::WorkerHeartbeat_DecEntry_DoNotUse* Arena::CreateMaybeMessage<::taskscheduler::WorkerHeartbeat_DecEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace taskscheduler {

enum TaskStatus : int {
  PENDING = 0,
  RUNNING = 1,
  SUCCESS = 2,
  FAILED = 3,
  TaskStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TaskStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TaskStatus_IsValid(int value);
constexpr TaskStatus TaskStatus_MIN = PENDING;
constexpr TaskStatus TaskStatus_MAX = FAILED;
constexpr int TaskStatus_ARRAYSIZE = TaskStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaskStatus_descriptor();
template<typename T>
inline const std::string& TaskStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TaskStatus_descriptor(), enum_t_value);
}
inline bool TaskStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TaskStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TaskStatus>(
    TaskStatus_descriptor(), name, value);
}
enum TaskType : int {
  FUNCTION = 0,
  COMMAND = 1,
  TaskType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TaskType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TaskType_IsValid(int value);
constexpr TaskType TaskType_MIN = FUNCTION;
constexpr TaskType TaskType_MAX = COMMAND;
constexpr int TaskType_ARRAYSIZE = TaskType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaskType_descriptor();
template<typename T>
inline const std::string& TaskType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TaskType_descriptor(), enum_t_value);
}
inline bool TaskType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TaskType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TaskType>(
    TaskType_descriptor(), name, value);
}
// ===================================================================

class Task_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Task_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Task_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Task_MetadataEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Task_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Task_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Task_MetadataEntry_DoNotUse& other);
  static const Task_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Task_MetadataEntry_DoNotUse*>(&_Task_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "taskscheduler.Task.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "taskscheduler.Task.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_proto_2ftask_2eproto;
};

// -------------------------------------------------------------------

class Task final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:taskscheduler.Task) */ {
 public:
  inline Task() : Task(nullptr) {}
  ~Task() override;
  explicit PROTOBUF_CONSTEXPR Task(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Task(const Task& from);
  Task(Task&& from) noexcept
    : Task() {
    *this = ::std::move(from);
  }

  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }
  inline Task& operator=(Task&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Task& default_instance() {
    return *internal_default_instance();
  }
  static inline const Task* internal_default_instance() {
    return reinterpret_cast<const Task*>(
               &_Task_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Task& a, Task& b) {
    a.Swap(&b);
  }
  inline void Swap(Task* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Task* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Task* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Task>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Task& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Task& from) {
    Task::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Task* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "taskscheduler.Task";
  }
  protected:
  explicit Task(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 11,
    kTaskIdFieldNumber = 1,
    kContentFieldNumber = 3,
    kWorkerIdFieldNumber = 9,
    kTypeFieldNumber = 2,
    kStatusFieldNumber = 10,
  };
  // map<string, string> metadata = 11;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string task_id = 1;
  void clear_task_id();
  const std::string& task_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_id();
  PROTOBUF_NODISCARD std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);
  private:
  const std::string& _internal_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(const std::string& value);
  std::string* _internal_mutable_task_id();
  public:

  // string content = 3;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // string worker_id = 9;
  void clear_worker_id();
  const std::string& worker_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_worker_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_worker_id();
  PROTOBUF_NODISCARD std::string* release_worker_id();
  void set_allocated_worker_id(std::string* worker_id);
  private:
  const std::string& _internal_worker_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_worker_id(const std::string& value);
  std::string* _internal_mutable_worker_id();
  public:

  // .taskscheduler.TaskType type = 2;
  void clear_type();
  ::taskscheduler::TaskType type() const;
  void set_type(::taskscheduler::TaskType value);
  private:
  ::taskscheduler::TaskType _internal_type() const;
  void _internal_set_type(::taskscheduler::TaskType value);
  public:

  // .taskscheduler.TaskStatus status = 10;
  void clear_status();
  ::taskscheduler::TaskStatus status() const;
  void set_status(::taskscheduler::TaskStatus value);
  private:
  ::taskscheduler::TaskStatus _internal_status() const;
  void _internal_set_status(::taskscheduler::TaskStatus value);
  public:

  // @@protoc_insertion_point(class_scope:taskscheduler.Task)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        Task_MetadataEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr worker_id_;
    int type_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2ftask_2eproto;
};
// -------------------------------------------------------------------

class TaskResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:taskscheduler.TaskResult) */ {
 public:
  inline TaskResult() : TaskResult(nullptr) {}
  ~TaskResult() override;
  explicit PROTOBUF_CONSTEXPR TaskResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TaskResult(const TaskResult& from);
  TaskResult(TaskResult&& from) noexcept
    : TaskResult() {
    *this = ::std::move(from);
  }

  inline TaskResult& operator=(const TaskResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskResult& operator=(TaskResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskResult* internal_default_instance() {
    return reinterpret_cast<const TaskResult*>(
               &_TaskResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TaskResult& a, TaskResult& b) {
    a.Swap(&b);
  }
  inline void Swap(TaskResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TaskResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TaskResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TaskResult& from) {
    TaskResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "taskscheduler.TaskResult";
  }
  protected:
  explicit TaskResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTaskIdFieldNumber = 1,
    kOutputFieldNumber = 3,
    kErrorMessageFieldNumber = 4,
    kWorkerIdFieldNumber = 8,
    kStartTimeFieldNumber = 5,
    kEndTimeFieldNumber = 6,
    kDurationMsFieldNumber = 7,
    kStatusFieldNumber = 2,
  };
  // string task_id = 1;
  void clear_task_id();
  const std::string& task_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_id();
  PROTOBUF_NODISCARD std::string* release_task_id();
  void set_allocated_task_id(std::string* task_id);
  private:
  const std::string& _internal_task_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_id(const std::string& value);
  std::string* _internal_mutable_task_id();
  public:

  // string output = 3;
  void clear_output();
  const std::string& output() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_output(ArgT0&& arg0, ArgT... args);
  std::string* mutable_output();
  PROTOBUF_NODISCARD std::string* release_output();
  void set_allocated_output(std::string* output);
  private:
  const std::string& _internal_output() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_output(const std::string& value);
  std::string* _internal_mutable_output();
  public:

  // string error_message = 4;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // string worker_id = 8;
  void clear_worker_id();
  const std::string& worker_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_worker_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_worker_id();
  PROTOBUF_NODISCARD std::string* release_worker_id();
  void set_allocated_worker_id(std::string* worker_id);
  private:
  const std::string& _internal_worker_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_worker_id(const std::string& value);
  std::string* _internal_mutable_worker_id();
  public:

  // int64 start_time = 5;
  void clear_start_time();
  int64_t start_time() const;
  void set_start_time(int64_t value);
  private:
  int64_t _internal_start_time() const;
  void _internal_set_start_time(int64_t value);
  public:

  // int64 end_time = 6;
  void clear_end_time();
  int64_t end_time() const;
  void set_end_time(int64_t value);
  private:
  int64_t _internal_end_time() const;
  void _internal_set_end_time(int64_t value);
  public:

  // int64 duration_ms = 7;
  void clear_duration_ms();
  int64_t duration_ms() const;
  void set_duration_ms(int64_t value);
  private:
  int64_t _internal_duration_ms() const;
  void _internal_set_duration_ms(int64_t value);
  public:

  // .taskscheduler.TaskStatus status = 2;
  void clear_status();
  ::taskscheduler::TaskStatus status() const;
  void set_status(::taskscheduler::TaskStatus value);
  private:
  ::taskscheduler::TaskStatus _internal_status() const;
  void _internal_set_status(::taskscheduler::TaskStatus value);
  public:

  // @@protoc_insertion_point(class_scope:taskscheduler.TaskResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr output_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr worker_id_;
    int64_t start_time_;
    int64_t end_time_;
    int64_t duration_ms_;
    int status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2ftask_2eproto;
};
// -------------------------------------------------------------------

class WorkerHeartbeat_DecEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WorkerHeartbeat_DecEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<WorkerHeartbeat_DecEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  WorkerHeartbeat_DecEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR WorkerHeartbeat_DecEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit WorkerHeartbeat_DecEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const WorkerHeartbeat_DecEntry_DoNotUse& other);
  static const WorkerHeartbeat_DecEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const WorkerHeartbeat_DecEntry_DoNotUse*>(&_WorkerHeartbeat_DecEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "taskscheduler.WorkerHeartbeat.DecEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "taskscheduler.WorkerHeartbeat.DecEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_proto_2ftask_2eproto;
};

// -------------------------------------------------------------------

class WorkerHeartbeat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:taskscheduler.WorkerHeartbeat) */ {
 public:
  inline WorkerHeartbeat() : WorkerHeartbeat(nullptr) {}
  ~WorkerHeartbeat() override;
  explicit PROTOBUF_CONSTEXPR WorkerHeartbeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkerHeartbeat(const WorkerHeartbeat& from);
  WorkerHeartbeat(WorkerHeartbeat&& from) noexcept
    : WorkerHeartbeat() {
    *this = ::std::move(from);
  }

  inline WorkerHeartbeat& operator=(const WorkerHeartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkerHeartbeat& operator=(WorkerHeartbeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkerHeartbeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkerHeartbeat* internal_default_instance() {
    return reinterpret_cast<const WorkerHeartbeat*>(
               &_WorkerHeartbeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(WorkerHeartbeat& a, WorkerHeartbeat& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkerHeartbeat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkerHeartbeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkerHeartbeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkerHeartbeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkerHeartbeat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkerHeartbeat& from) {
    WorkerHeartbeat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerHeartbeat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "taskscheduler.WorkerHeartbeat";
  }
  protected:
  explicit WorkerHeartbeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDecFieldNumber = 6,
    kWorkerIdFieldNumber = 1,
    kWorkerIpFieldNumber = 2,
    kTimestampFieldNumber = 4,
    kWorkerPortFieldNumber = 3,
    kIsHealthyFieldNumber = 5,
  };
  // map<string, string> dec = 6;
  int dec_size() const;
  private:
  int _internal_dec_size() const;
  public:
  void clear_dec();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_dec() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_dec();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      dec() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_dec();

  // string worker_id = 1;
  void clear_worker_id();
  const std::string& worker_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_worker_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_worker_id();
  PROTOBUF_NODISCARD std::string* release_worker_id();
  void set_allocated_worker_id(std::string* worker_id);
  private:
  const std::string& _internal_worker_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_worker_id(const std::string& value);
  std::string* _internal_mutable_worker_id();
  public:

  // string worker_ip = 2;
  void clear_worker_ip();
  const std::string& worker_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_worker_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_worker_ip();
  PROTOBUF_NODISCARD std::string* release_worker_ip();
  void set_allocated_worker_ip(std::string* worker_ip);
  private:
  const std::string& _internal_worker_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_worker_ip(const std::string& value);
  std::string* _internal_mutable_worker_ip();
  public:

  // int64 timestamp = 4;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // int32 worker_port = 3;
  void clear_worker_port();
  int32_t worker_port() const;
  void set_worker_port(int32_t value);
  private:
  int32_t _internal_worker_port() const;
  void _internal_set_worker_port(int32_t value);
  public:

  // bool is_healthy = 5;
  void clear_is_healthy();
  bool is_healthy() const;
  void set_is_healthy(bool value);
  private:
  bool _internal_is_healthy() const;
  void _internal_set_is_healthy(bool value);
  public:

  // @@protoc_insertion_point(class_scope:taskscheduler.WorkerHeartbeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        WorkerHeartbeat_DecEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> dec_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr worker_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr worker_ip_;
    int64_t timestamp_;
    int32_t worker_port_;
    bool is_healthy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2ftask_2eproto;
};
// -------------------------------------------------------------------

class SchedulerHeartbeat_DecEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SchedulerHeartbeat_DecEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SchedulerHeartbeat_DecEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  SchedulerHeartbeat_DecEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SchedulerHeartbeat_DecEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SchedulerHeartbeat_DecEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SchedulerHeartbeat_DecEntry_DoNotUse& other);
  static const SchedulerHeartbeat_DecEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SchedulerHeartbeat_DecEntry_DoNotUse*>(&_SchedulerHeartbeat_DecEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "taskscheduler.SchedulerHeartbeat.DecEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "taskscheduler.SchedulerHeartbeat.DecEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_proto_2ftask_2eproto;
};

// -------------------------------------------------------------------

class SchedulerHeartbeat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:taskscheduler.SchedulerHeartbeat) */ {
 public:
  inline SchedulerHeartbeat() : SchedulerHeartbeat(nullptr) {}
  ~SchedulerHeartbeat() override;
  explicit PROTOBUF_CONSTEXPR SchedulerHeartbeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchedulerHeartbeat(const SchedulerHeartbeat& from);
  SchedulerHeartbeat(SchedulerHeartbeat&& from) noexcept
    : SchedulerHeartbeat() {
    *this = ::std::move(from);
  }

  inline SchedulerHeartbeat& operator=(const SchedulerHeartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchedulerHeartbeat& operator=(SchedulerHeartbeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchedulerHeartbeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchedulerHeartbeat* internal_default_instance() {
    return reinterpret_cast<const SchedulerHeartbeat*>(
               &_SchedulerHeartbeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SchedulerHeartbeat& a, SchedulerHeartbeat& b) {
    a.Swap(&b);
  }
  inline void Swap(SchedulerHeartbeat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchedulerHeartbeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchedulerHeartbeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchedulerHeartbeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchedulerHeartbeat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SchedulerHeartbeat& from) {
    SchedulerHeartbeat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchedulerHeartbeat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "taskscheduler.SchedulerHeartbeat";
  }
  protected:
  explicit SchedulerHeartbeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDecFieldNumber = 6,
    kSchedulerIdFieldNumber = 1,
    kSchedulerIpFieldNumber = 2,
    kSchedulerPortFieldNumber = 3,
    kTimetampFieldNumber = 4,
    kIsHealthyFieldNumber = 5,
  };
  // map<string, string> dec = 6;
  int dec_size() const;
  private:
  int _internal_dec_size() const;
  public:
  void clear_dec();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_dec() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_dec();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      dec() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_dec();

  // string scheduler_id = 1;
  void clear_scheduler_id();
  const std::string& scheduler_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_scheduler_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_scheduler_id();
  PROTOBUF_NODISCARD std::string* release_scheduler_id();
  void set_allocated_scheduler_id(std::string* scheduler_id);
  private:
  const std::string& _internal_scheduler_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_scheduler_id(const std::string& value);
  std::string* _internal_mutable_scheduler_id();
  public:

  // string scheduler_ip = 2;
  void clear_scheduler_ip();
  const std::string& scheduler_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_scheduler_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_scheduler_ip();
  PROTOBUF_NODISCARD std::string* release_scheduler_ip();
  void set_allocated_scheduler_ip(std::string* scheduler_ip);
  private:
  const std::string& _internal_scheduler_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_scheduler_ip(const std::string& value);
  std::string* _internal_mutable_scheduler_ip();
  public:

  // int32 scheduler_port = 3;
  void clear_scheduler_port();
  int32_t scheduler_port() const;
  void set_scheduler_port(int32_t value);
  private:
  int32_t _internal_scheduler_port() const;
  void _internal_set_scheduler_port(int32_t value);
  public:

  // int32 timetamp = 4;
  void clear_timetamp();
  int32_t timetamp() const;
  void set_timetamp(int32_t value);
  private:
  int32_t _internal_timetamp() const;
  void _internal_set_timetamp(int32_t value);
  public:

  // bool is_healthy = 5;
  void clear_is_healthy();
  bool is_healthy() const;
  void set_is_healthy(bool value);
  private:
  bool _internal_is_healthy() const;
  void _internal_set_is_healthy(bool value);
  public:

  // @@protoc_insertion_point(class_scope:taskscheduler.SchedulerHeartbeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SchedulerHeartbeat_DecEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> dec_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scheduler_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scheduler_ip_;
    int32_t scheduler_port_;
    int32_t timetamp_;
    bool is_healthy_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2ftask_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Task

// string task_id = 1;
inline void Task::clear_task_id() {
  _impl_.task_id_.ClearToEmpty();
}
inline const std::string& Task::task_id() const {
  // @@protoc_insertion_point(field_get:taskscheduler.Task.task_id)
  return _internal_task_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Task::set_task_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.task_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taskscheduler.Task.task_id)
}
inline std::string* Task::mutable_task_id() {
  std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:taskscheduler.Task.task_id)
  return _s;
}
inline const std::string& Task::_internal_task_id() const {
  return _impl_.task_id_.Get();
}
inline void Task::_internal_set_task_id(const std::string& value) {
  
  _impl_.task_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Task::_internal_mutable_task_id() {
  
  return _impl_.task_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Task::release_task_id() {
  // @@protoc_insertion_point(field_release:taskscheduler.Task.task_id)
  return _impl_.task_id_.Release();
}
inline void Task::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    
  } else {
    
  }
  _impl_.task_id_.SetAllocated(task_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.task_id_.IsDefault()) {
    _impl_.task_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:taskscheduler.Task.task_id)
}

// .taskscheduler.TaskType type = 2;
inline void Task::clear_type() {
  _impl_.type_ = 0;
}
inline ::taskscheduler::TaskType Task::_internal_type() const {
  return static_cast< ::taskscheduler::TaskType >(_impl_.type_);
}
inline ::taskscheduler::TaskType Task::type() const {
  // @@protoc_insertion_point(field_get:taskscheduler.Task.type)
  return _internal_type();
}
inline void Task::_internal_set_type(::taskscheduler::TaskType value) {
  
  _impl_.type_ = value;
}
inline void Task::set_type(::taskscheduler::TaskType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:taskscheduler.Task.type)
}

// string content = 3;
inline void Task::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& Task::content() const {
  // @@protoc_insertion_point(field_get:taskscheduler.Task.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Task::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taskscheduler.Task.content)
}
inline std::string* Task::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:taskscheduler.Task.content)
  return _s;
}
inline const std::string& Task::_internal_content() const {
  return _impl_.content_.Get();
}
inline void Task::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* Task::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* Task::release_content() {
  // @@protoc_insertion_point(field_release:taskscheduler.Task.content)
  return _impl_.content_.Release();
}
inline void Task::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:taskscheduler.Task.content)
}

// string worker_id = 9;
inline void Task::clear_worker_id() {
  _impl_.worker_id_.ClearToEmpty();
}
inline const std::string& Task::worker_id() const {
  // @@protoc_insertion_point(field_get:taskscheduler.Task.worker_id)
  return _internal_worker_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Task::set_worker_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.worker_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taskscheduler.Task.worker_id)
}
inline std::string* Task::mutable_worker_id() {
  std::string* _s = _internal_mutable_worker_id();
  // @@protoc_insertion_point(field_mutable:taskscheduler.Task.worker_id)
  return _s;
}
inline const std::string& Task::_internal_worker_id() const {
  return _impl_.worker_id_.Get();
}
inline void Task::_internal_set_worker_id(const std::string& value) {
  
  _impl_.worker_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Task::_internal_mutable_worker_id() {
  
  return _impl_.worker_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Task::release_worker_id() {
  // @@protoc_insertion_point(field_release:taskscheduler.Task.worker_id)
  return _impl_.worker_id_.Release();
}
inline void Task::set_allocated_worker_id(std::string* worker_id) {
  if (worker_id != nullptr) {
    
  } else {
    
  }
  _impl_.worker_id_.SetAllocated(worker_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.worker_id_.IsDefault()) {
    _impl_.worker_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:taskscheduler.Task.worker_id)
}

// .taskscheduler.TaskStatus status = 10;
inline void Task::clear_status() {
  _impl_.status_ = 0;
}
inline ::taskscheduler::TaskStatus Task::_internal_status() const {
  return static_cast< ::taskscheduler::TaskStatus >(_impl_.status_);
}
inline ::taskscheduler::TaskStatus Task::status() const {
  // @@protoc_insertion_point(field_get:taskscheduler.Task.status)
  return _internal_status();
}
inline void Task::_internal_set_status(::taskscheduler::TaskStatus value) {
  
  _impl_.status_ = value;
}
inline void Task::set_status(::taskscheduler::TaskStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:taskscheduler.Task.status)
}

// map<string, string> metadata = 11;
inline int Task::_internal_metadata_size() const {
  return _impl_.metadata_.size();
}
inline int Task::metadata_size() const {
  return _internal_metadata_size();
}
inline void Task::clear_metadata() {
  _impl_.metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Task::_internal_metadata() const {
  return _impl_.metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Task::metadata() const {
  // @@protoc_insertion_point(field_map:taskscheduler.Task.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Task::_internal_mutable_metadata() {
  return _impl_.metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Task::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:taskscheduler.Task.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// TaskResult

// string task_id = 1;
inline void TaskResult::clear_task_id() {
  _impl_.task_id_.ClearToEmpty();
}
inline const std::string& TaskResult::task_id() const {
  // @@protoc_insertion_point(field_get:taskscheduler.TaskResult.task_id)
  return _internal_task_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskResult::set_task_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.task_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taskscheduler.TaskResult.task_id)
}
inline std::string* TaskResult::mutable_task_id() {
  std::string* _s = _internal_mutable_task_id();
  // @@protoc_insertion_point(field_mutable:taskscheduler.TaskResult.task_id)
  return _s;
}
inline const std::string& TaskResult::_internal_task_id() const {
  return _impl_.task_id_.Get();
}
inline void TaskResult::_internal_set_task_id(const std::string& value) {
  
  _impl_.task_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TaskResult::_internal_mutable_task_id() {
  
  return _impl_.task_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TaskResult::release_task_id() {
  // @@protoc_insertion_point(field_release:taskscheduler.TaskResult.task_id)
  return _impl_.task_id_.Release();
}
inline void TaskResult::set_allocated_task_id(std::string* task_id) {
  if (task_id != nullptr) {
    
  } else {
    
  }
  _impl_.task_id_.SetAllocated(task_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.task_id_.IsDefault()) {
    _impl_.task_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:taskscheduler.TaskResult.task_id)
}

// .taskscheduler.TaskStatus status = 2;
inline void TaskResult::clear_status() {
  _impl_.status_ = 0;
}
inline ::taskscheduler::TaskStatus TaskResult::_internal_status() const {
  return static_cast< ::taskscheduler::TaskStatus >(_impl_.status_);
}
inline ::taskscheduler::TaskStatus TaskResult::status() const {
  // @@protoc_insertion_point(field_get:taskscheduler.TaskResult.status)
  return _internal_status();
}
inline void TaskResult::_internal_set_status(::taskscheduler::TaskStatus value) {
  
  _impl_.status_ = value;
}
inline void TaskResult::set_status(::taskscheduler::TaskStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:taskscheduler.TaskResult.status)
}

// string output = 3;
inline void TaskResult::clear_output() {
  _impl_.output_.ClearToEmpty();
}
inline const std::string& TaskResult::output() const {
  // @@protoc_insertion_point(field_get:taskscheduler.TaskResult.output)
  return _internal_output();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskResult::set_output(ArgT0&& arg0, ArgT... args) {
 
 _impl_.output_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taskscheduler.TaskResult.output)
}
inline std::string* TaskResult::mutable_output() {
  std::string* _s = _internal_mutable_output();
  // @@protoc_insertion_point(field_mutable:taskscheduler.TaskResult.output)
  return _s;
}
inline const std::string& TaskResult::_internal_output() const {
  return _impl_.output_.Get();
}
inline void TaskResult::_internal_set_output(const std::string& value) {
  
  _impl_.output_.Set(value, GetArenaForAllocation());
}
inline std::string* TaskResult::_internal_mutable_output() {
  
  return _impl_.output_.Mutable(GetArenaForAllocation());
}
inline std::string* TaskResult::release_output() {
  // @@protoc_insertion_point(field_release:taskscheduler.TaskResult.output)
  return _impl_.output_.Release();
}
inline void TaskResult::set_allocated_output(std::string* output) {
  if (output != nullptr) {
    
  } else {
    
  }
  _impl_.output_.SetAllocated(output, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.output_.IsDefault()) {
    _impl_.output_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:taskscheduler.TaskResult.output)
}

// string error_message = 4;
inline void TaskResult::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& TaskResult::error_message() const {
  // @@protoc_insertion_point(field_get:taskscheduler.TaskResult.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskResult::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taskscheduler.TaskResult.error_message)
}
inline std::string* TaskResult::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:taskscheduler.TaskResult.error_message)
  return _s;
}
inline const std::string& TaskResult::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void TaskResult::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* TaskResult::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* TaskResult::release_error_message() {
  // @@protoc_insertion_point(field_release:taskscheduler.TaskResult.error_message)
  return _impl_.error_message_.Release();
}
inline void TaskResult::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:taskscheduler.TaskResult.error_message)
}

// int64 start_time = 5;
inline void TaskResult::clear_start_time() {
  _impl_.start_time_ = int64_t{0};
}
inline int64_t TaskResult::_internal_start_time() const {
  return _impl_.start_time_;
}
inline int64_t TaskResult::start_time() const {
  // @@protoc_insertion_point(field_get:taskscheduler.TaskResult.start_time)
  return _internal_start_time();
}
inline void TaskResult::_internal_set_start_time(int64_t value) {
  
  _impl_.start_time_ = value;
}
inline void TaskResult::set_start_time(int64_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:taskscheduler.TaskResult.start_time)
}

// int64 end_time = 6;
inline void TaskResult::clear_end_time() {
  _impl_.end_time_ = int64_t{0};
}
inline int64_t TaskResult::_internal_end_time() const {
  return _impl_.end_time_;
}
inline int64_t TaskResult::end_time() const {
  // @@protoc_insertion_point(field_get:taskscheduler.TaskResult.end_time)
  return _internal_end_time();
}
inline void TaskResult::_internal_set_end_time(int64_t value) {
  
  _impl_.end_time_ = value;
}
inline void TaskResult::set_end_time(int64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:taskscheduler.TaskResult.end_time)
}

// int64 duration_ms = 7;
inline void TaskResult::clear_duration_ms() {
  _impl_.duration_ms_ = int64_t{0};
}
inline int64_t TaskResult::_internal_duration_ms() const {
  return _impl_.duration_ms_;
}
inline int64_t TaskResult::duration_ms() const {
  // @@protoc_insertion_point(field_get:taskscheduler.TaskResult.duration_ms)
  return _internal_duration_ms();
}
inline void TaskResult::_internal_set_duration_ms(int64_t value) {
  
  _impl_.duration_ms_ = value;
}
inline void TaskResult::set_duration_ms(int64_t value) {
  _internal_set_duration_ms(value);
  // @@protoc_insertion_point(field_set:taskscheduler.TaskResult.duration_ms)
}

// string worker_id = 8;
inline void TaskResult::clear_worker_id() {
  _impl_.worker_id_.ClearToEmpty();
}
inline const std::string& TaskResult::worker_id() const {
  // @@protoc_insertion_point(field_get:taskscheduler.TaskResult.worker_id)
  return _internal_worker_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TaskResult::set_worker_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.worker_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taskscheduler.TaskResult.worker_id)
}
inline std::string* TaskResult::mutable_worker_id() {
  std::string* _s = _internal_mutable_worker_id();
  // @@protoc_insertion_point(field_mutable:taskscheduler.TaskResult.worker_id)
  return _s;
}
inline const std::string& TaskResult::_internal_worker_id() const {
  return _impl_.worker_id_.Get();
}
inline void TaskResult::_internal_set_worker_id(const std::string& value) {
  
  _impl_.worker_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TaskResult::_internal_mutable_worker_id() {
  
  return _impl_.worker_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TaskResult::release_worker_id() {
  // @@protoc_insertion_point(field_release:taskscheduler.TaskResult.worker_id)
  return _impl_.worker_id_.Release();
}
inline void TaskResult::set_allocated_worker_id(std::string* worker_id) {
  if (worker_id != nullptr) {
    
  } else {
    
  }
  _impl_.worker_id_.SetAllocated(worker_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.worker_id_.IsDefault()) {
    _impl_.worker_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:taskscheduler.TaskResult.worker_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// WorkerHeartbeat

// string worker_id = 1;
inline void WorkerHeartbeat::clear_worker_id() {
  _impl_.worker_id_.ClearToEmpty();
}
inline const std::string& WorkerHeartbeat::worker_id() const {
  // @@protoc_insertion_point(field_get:taskscheduler.WorkerHeartbeat.worker_id)
  return _internal_worker_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkerHeartbeat::set_worker_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.worker_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taskscheduler.WorkerHeartbeat.worker_id)
}
inline std::string* WorkerHeartbeat::mutable_worker_id() {
  std::string* _s = _internal_mutable_worker_id();
  // @@protoc_insertion_point(field_mutable:taskscheduler.WorkerHeartbeat.worker_id)
  return _s;
}
inline const std::string& WorkerHeartbeat::_internal_worker_id() const {
  return _impl_.worker_id_.Get();
}
inline void WorkerHeartbeat::_internal_set_worker_id(const std::string& value) {
  
  _impl_.worker_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkerHeartbeat::_internal_mutable_worker_id() {
  
  return _impl_.worker_id_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkerHeartbeat::release_worker_id() {
  // @@protoc_insertion_point(field_release:taskscheduler.WorkerHeartbeat.worker_id)
  return _impl_.worker_id_.Release();
}
inline void WorkerHeartbeat::set_allocated_worker_id(std::string* worker_id) {
  if (worker_id != nullptr) {
    
  } else {
    
  }
  _impl_.worker_id_.SetAllocated(worker_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.worker_id_.IsDefault()) {
    _impl_.worker_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:taskscheduler.WorkerHeartbeat.worker_id)
}

// string worker_ip = 2;
inline void WorkerHeartbeat::clear_worker_ip() {
  _impl_.worker_ip_.ClearToEmpty();
}
inline const std::string& WorkerHeartbeat::worker_ip() const {
  // @@protoc_insertion_point(field_get:taskscheduler.WorkerHeartbeat.worker_ip)
  return _internal_worker_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WorkerHeartbeat::set_worker_ip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.worker_ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taskscheduler.WorkerHeartbeat.worker_ip)
}
inline std::string* WorkerHeartbeat::mutable_worker_ip() {
  std::string* _s = _internal_mutable_worker_ip();
  // @@protoc_insertion_point(field_mutable:taskscheduler.WorkerHeartbeat.worker_ip)
  return _s;
}
inline const std::string& WorkerHeartbeat::_internal_worker_ip() const {
  return _impl_.worker_ip_.Get();
}
inline void WorkerHeartbeat::_internal_set_worker_ip(const std::string& value) {
  
  _impl_.worker_ip_.Set(value, GetArenaForAllocation());
}
inline std::string* WorkerHeartbeat::_internal_mutable_worker_ip() {
  
  return _impl_.worker_ip_.Mutable(GetArenaForAllocation());
}
inline std::string* WorkerHeartbeat::release_worker_ip() {
  // @@protoc_insertion_point(field_release:taskscheduler.WorkerHeartbeat.worker_ip)
  return _impl_.worker_ip_.Release();
}
inline void WorkerHeartbeat::set_allocated_worker_ip(std::string* worker_ip) {
  if (worker_ip != nullptr) {
    
  } else {
    
  }
  _impl_.worker_ip_.SetAllocated(worker_ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.worker_ip_.IsDefault()) {
    _impl_.worker_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:taskscheduler.WorkerHeartbeat.worker_ip)
}

// int32 worker_port = 3;
inline void WorkerHeartbeat::clear_worker_port() {
  _impl_.worker_port_ = 0;
}
inline int32_t WorkerHeartbeat::_internal_worker_port() const {
  return _impl_.worker_port_;
}
inline int32_t WorkerHeartbeat::worker_port() const {
  // @@protoc_insertion_point(field_get:taskscheduler.WorkerHeartbeat.worker_port)
  return _internal_worker_port();
}
inline void WorkerHeartbeat::_internal_set_worker_port(int32_t value) {
  
  _impl_.worker_port_ = value;
}
inline void WorkerHeartbeat::set_worker_port(int32_t value) {
  _internal_set_worker_port(value);
  // @@protoc_insertion_point(field_set:taskscheduler.WorkerHeartbeat.worker_port)
}

// int64 timestamp = 4;
inline void WorkerHeartbeat::clear_timestamp() {
  _impl_.timestamp_ = int64_t{0};
}
inline int64_t WorkerHeartbeat::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline int64_t WorkerHeartbeat::timestamp() const {
  // @@protoc_insertion_point(field_get:taskscheduler.WorkerHeartbeat.timestamp)
  return _internal_timestamp();
}
inline void WorkerHeartbeat::_internal_set_timestamp(int64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void WorkerHeartbeat::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:taskscheduler.WorkerHeartbeat.timestamp)
}

// bool is_healthy = 5;
inline void WorkerHeartbeat::clear_is_healthy() {
  _impl_.is_healthy_ = false;
}
inline bool WorkerHeartbeat::_internal_is_healthy() const {
  return _impl_.is_healthy_;
}
inline bool WorkerHeartbeat::is_healthy() const {
  // @@protoc_insertion_point(field_get:taskscheduler.WorkerHeartbeat.is_healthy)
  return _internal_is_healthy();
}
inline void WorkerHeartbeat::_internal_set_is_healthy(bool value) {
  
  _impl_.is_healthy_ = value;
}
inline void WorkerHeartbeat::set_is_healthy(bool value) {
  _internal_set_is_healthy(value);
  // @@protoc_insertion_point(field_set:taskscheduler.WorkerHeartbeat.is_healthy)
}

// map<string, string> dec = 6;
inline int WorkerHeartbeat::_internal_dec_size() const {
  return _impl_.dec_.size();
}
inline int WorkerHeartbeat::dec_size() const {
  return _internal_dec_size();
}
inline void WorkerHeartbeat::clear_dec() {
  _impl_.dec_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
WorkerHeartbeat::_internal_dec() const {
  return _impl_.dec_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
WorkerHeartbeat::dec() const {
  // @@protoc_insertion_point(field_map:taskscheduler.WorkerHeartbeat.dec)
  return _internal_dec();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
WorkerHeartbeat::_internal_mutable_dec() {
  return _impl_.dec_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
WorkerHeartbeat::mutable_dec() {
  // @@protoc_insertion_point(field_mutable_map:taskscheduler.WorkerHeartbeat.dec)
  return _internal_mutable_dec();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SchedulerHeartbeat

// string scheduler_id = 1;
inline void SchedulerHeartbeat::clear_scheduler_id() {
  _impl_.scheduler_id_.ClearToEmpty();
}
inline const std::string& SchedulerHeartbeat::scheduler_id() const {
  // @@protoc_insertion_point(field_get:taskscheduler.SchedulerHeartbeat.scheduler_id)
  return _internal_scheduler_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchedulerHeartbeat::set_scheduler_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.scheduler_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taskscheduler.SchedulerHeartbeat.scheduler_id)
}
inline std::string* SchedulerHeartbeat::mutable_scheduler_id() {
  std::string* _s = _internal_mutable_scheduler_id();
  // @@protoc_insertion_point(field_mutable:taskscheduler.SchedulerHeartbeat.scheduler_id)
  return _s;
}
inline const std::string& SchedulerHeartbeat::_internal_scheduler_id() const {
  return _impl_.scheduler_id_.Get();
}
inline void SchedulerHeartbeat::_internal_set_scheduler_id(const std::string& value) {
  
  _impl_.scheduler_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedulerHeartbeat::_internal_mutable_scheduler_id() {
  
  return _impl_.scheduler_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SchedulerHeartbeat::release_scheduler_id() {
  // @@protoc_insertion_point(field_release:taskscheduler.SchedulerHeartbeat.scheduler_id)
  return _impl_.scheduler_id_.Release();
}
inline void SchedulerHeartbeat::set_allocated_scheduler_id(std::string* scheduler_id) {
  if (scheduler_id != nullptr) {
    
  } else {
    
  }
  _impl_.scheduler_id_.SetAllocated(scheduler_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.scheduler_id_.IsDefault()) {
    _impl_.scheduler_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:taskscheduler.SchedulerHeartbeat.scheduler_id)
}

// string scheduler_ip = 2;
inline void SchedulerHeartbeat::clear_scheduler_ip() {
  _impl_.scheduler_ip_.ClearToEmpty();
}
inline const std::string& SchedulerHeartbeat::scheduler_ip() const {
  // @@protoc_insertion_point(field_get:taskscheduler.SchedulerHeartbeat.scheduler_ip)
  return _internal_scheduler_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchedulerHeartbeat::set_scheduler_ip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.scheduler_ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:taskscheduler.SchedulerHeartbeat.scheduler_ip)
}
inline std::string* SchedulerHeartbeat::mutable_scheduler_ip() {
  std::string* _s = _internal_mutable_scheduler_ip();
  // @@protoc_insertion_point(field_mutable:taskscheduler.SchedulerHeartbeat.scheduler_ip)
  return _s;
}
inline const std::string& SchedulerHeartbeat::_internal_scheduler_ip() const {
  return _impl_.scheduler_ip_.Get();
}
inline void SchedulerHeartbeat::_internal_set_scheduler_ip(const std::string& value) {
  
  _impl_.scheduler_ip_.Set(value, GetArenaForAllocation());
}
inline std::string* SchedulerHeartbeat::_internal_mutable_scheduler_ip() {
  
  return _impl_.scheduler_ip_.Mutable(GetArenaForAllocation());
}
inline std::string* SchedulerHeartbeat::release_scheduler_ip() {
  // @@protoc_insertion_point(field_release:taskscheduler.SchedulerHeartbeat.scheduler_ip)
  return _impl_.scheduler_ip_.Release();
}
inline void SchedulerHeartbeat::set_allocated_scheduler_ip(std::string* scheduler_ip) {
  if (scheduler_ip != nullptr) {
    
  } else {
    
  }
  _impl_.scheduler_ip_.SetAllocated(scheduler_ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.scheduler_ip_.IsDefault()) {
    _impl_.scheduler_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:taskscheduler.SchedulerHeartbeat.scheduler_ip)
}

// int32 scheduler_port = 3;
inline void SchedulerHeartbeat::clear_scheduler_port() {
  _impl_.scheduler_port_ = 0;
}
inline int32_t SchedulerHeartbeat::_internal_scheduler_port() const {
  return _impl_.scheduler_port_;
}
inline int32_t SchedulerHeartbeat::scheduler_port() const {
  // @@protoc_insertion_point(field_get:taskscheduler.SchedulerHeartbeat.scheduler_port)
  return _internal_scheduler_port();
}
inline void SchedulerHeartbeat::_internal_set_scheduler_port(int32_t value) {
  
  _impl_.scheduler_port_ = value;
}
inline void SchedulerHeartbeat::set_scheduler_port(int32_t value) {
  _internal_set_scheduler_port(value);
  // @@protoc_insertion_point(field_set:taskscheduler.SchedulerHeartbeat.scheduler_port)
}

// int32 timetamp = 4;
inline void SchedulerHeartbeat::clear_timetamp() {
  _impl_.timetamp_ = 0;
}
inline int32_t SchedulerHeartbeat::_internal_timetamp() const {
  return _impl_.timetamp_;
}
inline int32_t SchedulerHeartbeat::timetamp() const {
  // @@protoc_insertion_point(field_get:taskscheduler.SchedulerHeartbeat.timetamp)
  return _internal_timetamp();
}
inline void SchedulerHeartbeat::_internal_set_timetamp(int32_t value) {
  
  _impl_.timetamp_ = value;
}
inline void SchedulerHeartbeat::set_timetamp(int32_t value) {
  _internal_set_timetamp(value);
  // @@protoc_insertion_point(field_set:taskscheduler.SchedulerHeartbeat.timetamp)
}

// bool is_healthy = 5;
inline void SchedulerHeartbeat::clear_is_healthy() {
  _impl_.is_healthy_ = false;
}
inline bool SchedulerHeartbeat::_internal_is_healthy() const {
  return _impl_.is_healthy_;
}
inline bool SchedulerHeartbeat::is_healthy() const {
  // @@protoc_insertion_point(field_get:taskscheduler.SchedulerHeartbeat.is_healthy)
  return _internal_is_healthy();
}
inline void SchedulerHeartbeat::_internal_set_is_healthy(bool value) {
  
  _impl_.is_healthy_ = value;
}
inline void SchedulerHeartbeat::set_is_healthy(bool value) {
  _internal_set_is_healthy(value);
  // @@protoc_insertion_point(field_set:taskscheduler.SchedulerHeartbeat.is_healthy)
}

// map<string, string> dec = 6;
inline int SchedulerHeartbeat::_internal_dec_size() const {
  return _impl_.dec_.size();
}
inline int SchedulerHeartbeat::dec_size() const {
  return _internal_dec_size();
}
inline void SchedulerHeartbeat::clear_dec() {
  _impl_.dec_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SchedulerHeartbeat::_internal_dec() const {
  return _impl_.dec_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SchedulerHeartbeat::dec() const {
  // @@protoc_insertion_point(field_map:taskscheduler.SchedulerHeartbeat.dec)
  return _internal_dec();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SchedulerHeartbeat::_internal_mutable_dec() {
  return _impl_.dec_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SchedulerHeartbeat::mutable_dec() {
  // @@protoc_insertion_point(field_mutable_map:taskscheduler.SchedulerHeartbeat.dec)
  return _internal_mutable_dec();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace taskscheduler

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::taskscheduler::TaskStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::taskscheduler::TaskStatus>() {
  return ::taskscheduler::TaskStatus_descriptor();
}
template <> struct is_proto_enum< ::taskscheduler::TaskType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::taskscheduler::TaskType>() {
  return ::taskscheduler::TaskType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_proto_2ftask_2eproto
